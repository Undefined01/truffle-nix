package website.lihan.trufflenix;

import com.oracle.truffle.api.CallTarget;
import com.oracle.truffle.api.RootCallTarget;
import com.oracle.truffle.api.TruffleLanguage;
import com.oracle.truffle.api.TruffleLanguage.ContextPolicy;
import com.oracle.truffle.api.debug.DebuggerTags;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.RootNode;
import com.oracle.truffle.api.object.DynamicObject;
import com.oracle.truffle.api.object.DynamicObjectLibrary;
import com.oracle.truffle.api.source.Source;
import com.oracle.truffle.api.strings.TruffleString;
import java.util.Map;
import website.lihan.trufflenix.nodes.NixRootNode;
import website.lihan.trufflenix.nodes.expressions.functions.ReadFunctionArgExprNode;
import website.lihan.trufflenix.nodes.expressions.functions.builtins.TypeOfNodeGen;
import website.lihan.trufflenix.parser.NixParser;
import website.lihan.trufflenix.runtime.FunctionObject;
import website.lihan.trufflenix.runtime.NixContext;

/**
 * SL is a simple language to demonstrate and showcase features of Truffle. The implementation is as
 * simple and clean as possible in order to help understanding the ideas and concepts of Truffle.
 * The language has first class functions, and objects are key-value stores.
 *
 * <p>SL is dynamically typed, i.e., there are no type names specified by the programmer. SL is
 * strongly typed, i.e., there is no automatic conversion between types. If an operation is not
 * available for the types encountered at run time, a type error is reported and execution is
 * stopped. For example, {@code 4 - "2"} results in a type error because subtraction is only defined
 * for numbers.
 *
 * <p><b>Types:</b>
 *
 * <ul>
 *   <li>Number: arbitrary precision integer numbers. The implementation uses the Java primitive
 *       type {@code long} to represent numbers that fit into the 64 bit range, and {@link
 *       SLBigInteger} for numbers that exceed the range. Using a primitive type such as {@code
 *       long} is crucial for performance.
 *   <li>Boolean: implemented as the Java primitive type {@code boolean}.
 *   <li>String: implemented as the Java standard type {@link String}.
 *   <li>Function: implementation type {@link SLFunction}.
 *   <li>Object: efficient implementation using the object model provided by Truffle. The
 *       implementation type of objects is a subclass of {@link DynamicObject}.
 *   <li>Null (with only one value {@code null}): implemented as the singleton {@link
 *       SLNull#SINGLETON}.
 * </ul>
 *
 * The class {@link SLTypes} lists these types for the Truffle DSL, i.e., for type-specialized
 * operations that are specified using Truffle DSL annotations.
 *
 * <p><b>Language concepts:</b>
 *
 * <ul>
 *   <li>Literals for {@link SLBigIntegerLiteralNode numbers} , {@link SLStringLiteralNode strings},
 *       and {@link SLFunctionLiteralNode functions}.
 *   <li>Basic arithmetic, logical, and comparison operations: {@link SLAddNode +}, {@link SLSubNode
 *       -}, {@link SLMulNode *}, {@link SLDivNode /}, {@link SLLogicalAndNode logical and}, {@link
 *       SLLogicalOrNode logical or}, {@link SLEqualNode ==}, !=, {@link SLLessThanNode &lt;},
 *       {@link SLLessOrEqualNode &le;}, &gt;, &ge;.
 *   <li>Local variables: local variables must be defined (via a {@link SLWriteLocalVariableNode
 *       write}) before they can be used (by a {@link SLReadLocalVariableNode read}). Local
 *       variables are not visible outside of the block where they were first defined.
 *   <li>Basic control flow statements: {@link SLBlockNode blocks}, {@link SLIfNode if}, {@link
 *       SLWhileNode while} with {@link SLBreakNode break} and {@link SLContinueNode continue},
 *       {@link SLReturnNode return}.
 *   <li>Debugging control: {@link SLDebuggerNode debugger} statement uses {@link
 *       DebuggerTags#AlwaysHalt} tag to halt the execution when run under the debugger.
 *   <li>Function calls: {@link SLInvokeNode invocations} are efficiently implemented with {@link
 *       SLDispatchNode polymorphic inline caches}.
 *   <li>Object access: {@link SLReadPropertyNode} and {@link SLWritePropertyNode} use a cached
 *       {@link DynamicObjectLibrary} as the polymorphic inline cache for property reads and writes,
 *       respectively.
 * </ul>
 *
 * <p><b>Syntax and parsing:</b><br>
 * The syntax is described as an attributed grammar. The {@link SimpleLanguageParser} and {@link
 * SimpleLanguageLexer} are automatically generated by ANTLR 4. The grammar contains semantic
 * actions that build the AST for a method. To keep these semantic actions short, they are mostly
 * calls to the {@link SLNodeFactory} that performs the actual node creation. All functions found in
 * the SL source are added to the {@link SLFunctionRegistry}, which is accessible from the {@link
 * SLContext}.
 *
 * <p><b>Builtin functions:</b><br>
 * Library functions that are available to every SL source without prior definition are called
 * builtin functions. They are added to the {@link SLFunctionRegistry} when the {@link SLContext} is
 * created. Some of the current builtin functions are
 *
 * <ul>
 *   <li>{@link SLReadlnBuiltin readln}: Read a String from the {@link SLContext#getInput() standard
 *       input}.
 *   <li>{@link SLPrintlnBuiltin println}: Write a value to the {@link SLContext#getOutput()
 *       standard output}.
 *   <li>{@link SLNanoTimeBuiltin nanoTime}: Returns the value of a high-resolution time, in
 *       nanoseconds.
 *   <li>{@link SLDefineFunctionBuiltin defineFunction}: Parses the functions provided as a String
 *       argument and adds them to the function registry. Functions that are already defined are
 *       replaced with the new version.
 *   <li>{@link SLStackTraceBuiltin stckTrace}: Print all function activations with all local
 *       variables.
 * </ul>
 */
@TruffleLanguage.Registration(
    id = NixLanguage.ID,
    name = "Nix",
    defaultMimeType = NixLanguage.MIME_TYPE,
    characterMimeTypes = NixLanguage.MIME_TYPE,
    contextPolicy = ContextPolicy.SHARED,
    website = "https://www.graalvm.org/graalvm-as-a-platform/implement-language/")
public final class NixLanguage extends TruffleLanguage<NixContext> {

  public static final String ID = "nix";
  public static final String MIME_TYPE = "application/x-nix";
  private static final Source BUILTIN_SOURCE =
      Source.newBuilder(NixLanguage.ID, "", "Nix builtin").build();

  public static final TruffleString.Encoding STRING_ENCODING = TruffleString.Encoding.UTF_16;
  private static final LanguageReference<NixLanguage> REF =
          LanguageReference.create(NixLanguage.class);

  /** Retrieve the current language instance for the given {@link Node}. */
  public static NixLanguage get(Node node) {
      return REF.get(node);
  }

  @Override
  protected CallTarget parse(ParsingRequest request) throws Exception {
    Source source = request.getSource();
    Map<TruffleString, RootCallTarget> functions;

    var nixNode = NixParser.parse(source);

    RootNode evalRootNode = new NixRootNode(this, nixNode);
    return evalRootNode.getCallTarget();
  }

  @Override
  protected NixContext createContext(Env env) {
    var context = new NixContext();

    var typeOfRootNode =
        new NixRootNode(this, TypeOfNodeGen.create(new ReadFunctionArgExprNode(0)));
    context.globalScopeObject.newConstant(
        "builtins.typeOf", new FunctionObject(typeOfRootNode.getCallTarget()));

    return context;
  }
}
